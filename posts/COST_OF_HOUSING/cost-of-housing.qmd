---
title: "How expensive is housing in the US?"
description: "An examination of the cost of housing in the US over time."
categories: [economics, housing, deep dive]
format: html
date-modified: last-modified
date-format: long
code-links:
  - text: repository
    icon: github
    href: "https://github.com/jon-kane/echinos/tree/main/posts/COST_OF_HOUSING"
---

::: {.callout-warning}
## Work in Progress
I am actively updating this post. Content will change as I work my way through this article.
:::

```{r setup}
#| include: false

source(here::here("_common.R"))
library(tidyquant)
library(ggiraph)
library(patchwork)
library(scales)
library(knitr)

# all the data wrangling and modeling done upfront to reference values:

# ------------------------------------------------------------------------------
# national data

national_data = readRDS(here::here("posts/COST_OF_HOUSING/national-data.rds"))
attach(national_data)

cpi_baseline_year = 2026

cpi_baseline = tb_nm %>% 
  filter(symbol == "CPIAUCSL", year(date) == cpi_baseline_year, month(date) == 1) %>% 
  pull(price)

tb_final01 = tb_nm %>% # national data structured
  mutate(
    symbol = case_match(
      symbol,
      "CPIAUCSL"      ~ "cpi",
      "MSPUS"         ~ "home",
      "MORTGAGE30US"  ~ "rate",
      "MEHOINUSA646N" ~ "income"
  )) %>% 
  select(-price_raw) %>% 
  pivot_wider(
    names_from = symbol,
    values_from = c(price, pred_sd),
    names_glue = "{symbol}_{.value}"
  ) %>% 
  mutate(
    inflation_adj = cpi_price / cpi_baseline,
    # Real Home Price (2025 Dollars)
    home_real = home_price / inflation_adj,
    # Error Prop: SD_z = z * sqrt((SD_x/x)^2 + (SD_y/y)^2)
    home_real_sd = home_real * sqrt((home_pred_sd/home_price)^2 + (cpi_pred_sd/cpi_price)^2),
    home_real_l = home_real - 3 * home_real_sd,
    home_real_u = home_real + 3 * home_real_sd,
    # Real Income (2025 Dollars)
    income_real = income_price / inflation_adj,
    income_real_sd = income_real * sqrt((income_pred_sd/income_price)^2 + (cpi_pred_sd/cpi_price)^2),
    income_real_l = income_real - 3 * income_real_sd,
    income_real_u = income_real + 3 * income_real_sd
  ) %>% 
  mutate(
    # Mortgage Payment Logic
    r_monthly = (rate_price / 100) / 12,
    n_payments = 360,
    factor = (r_monthly * (1 + r_monthly)^n_payments) / ((1 + r_monthly)^n_payments - 1),
    payment = (0.8 * home_real) * factor,
    # Payment SD scales linearly with Home SD (assuming rate error is negligible/zero)
    payment_sd = (0.8 * home_real_sd) * factor,
    payment_l = payment - 3 * payment_sd,
    payment_u = payment + 3 * payment_sd
  ) %>% 
  mutate(
    # Mortgage Payment / Monthly Income
    dti_ratio = payment / (income_real / 12),
    dti_sd = dti_ratio * sqrt((payment_sd/payment)^2 + (income_real_sd/income_real)^2),
    dti_l = dti_ratio - 3 * dti_sd,
    dti_u = dti_ratio + 3 * dti_sd,
    # Home Price / Annual Income
    pi_ratio = home_price / income_price,
    pi_sd = pi_ratio * sqrt((home_pred_sd/home_price)^2 + (income_pred_sd/income_price)^2),
    pi_l = pi_ratio - 3 * pi_sd,
    pi_u = pi_ratio + 3 * pi_sd
  )

# helper function to get...
# a linear model
# data that forms its prediction with intervals
# ECDF
getStuff = function(p, data_) {
  f = reformulate("date", response = p)
  
  lm_ = lm(
    formula = f,
    data = data_  
  )

  tb_lm = lm_$model %>% 
    bind_cols(
      predict(lm_, ., se.fit = T) %>% 
        magrittr::extract(c("fit", "se.fit")) %>% 
        as_tibble()
    ) %>% 
    mutate(fit_upper = fit + 3*se.fit) %>% 
    mutate(fit_lower = fit - 3*se.fit)
  
  getPercentile = ecdf(tb_lm[[p]])
  
  target_percentile = getPercentile(last(tb_lm[[p]]))
  
  list(
    mod = lm_,
    tb = tb_lm,
    getPercentile = getPercentile,
    tp = target_percentile
  ) %>% return()
}

# model data of the adjusted median home price
hp_data = getStuff("home_real", tb_final01)

# model data of the adjusted household income
hi_data = getStuff("income_real", tb_final01)

# model data of price/income ratio
pi_data = getStuff("pi_ratio", tb_final01)

# model data of debt-to-income ratio for monthly mortgage
di_data = getStuff("dti_ratio", tb_final01)
```

# tl;dr

**Things are bad, but not as bad as you might think.**

At a national scale,

- From `r format(min(hp_data$tb$date), '%B %Y')` to `r format(max(hp_data$tb$date), '%B %Y')`, the adjusted median home price (`r cpi_baseline_year` dollars) has **increased by `r scales::dollar(coef(hp_data$mod)[2]*365, 2)`  per year on average**. As of `r format(max(hp_data$tb$date), '%B %Y')`, the adjusted median home price stands at `r scales::dollar(last(hp_data$tb$home_real), 2)`, placing it in the **`r scales::ordinal(hp_data$tp * 100)` percentile of all observations** in this period.
- From `r format(min(hi_data$tb$date), '%B %Y')` to `r format(max(hi_data$tb$date), '%B %Y')`, the adjusted median household income (`r cpi_baseline_year` dollars) has **increased by `r scales::dollar(coef(hi_data$mod)[2]*365, 2)`  per year on average**. As of `r format(max(hp_data$tb$date), '%B %Y')`, the adjusted median household income stands at `r scales::dollar(last(hi_data$tb$home_real), 2)`, placing it in the **`r scales::ordinal(hi_data$tp * 100)` percentile of all observations** in this period.
- From `r format(min(pi_data$tb$date), '%B %Y')` to `r format(max(pi_data$tb$date), '%B %Y')`, the price-to-income ratio of a home has **increased by `r round(coef(pi_data$mod)[2]*365*100, 2)` percentage points (pp) per year on average**. As of `r format(max(pi_data$tb$date), '%B %Y')`, the ratio stands at `r round(last(pi_data$tb$pi_ratio), 2)`^[Meaning the typical house costs the typical household `r round(last(pi_data$tb$pi_ratio), 2)` $\times$ their gross annual income], placing it in the **`r scales::ordinal(pi_data$tp * 100)` percentile of all observations** in this period.
- From `r format(min(di_data$tb$date), '%B %Y')` to `r format(max(di_data$tb$date), '%B %Y')`, the mortgage debt-to-income ratio has **decreased by `r round(coef(di_data$mod)[2]*365*100, 2)` pp per year on average**. As of `r format(max(di_data$tb$date), '%B %Y')`, the ratio stands at `r round(last(di_data$tb$dti_ratio), 2)`^[Meaning the typical household would spend `r round(last(di_data$tb$dti_ratio), 2)` $\times$ their monthly income on the typical mortgage. This calculation assumes only interest and principal.], placing it in the **`r scales::ordinal(di_data$tp * 100)` percentile of all observations** in this period.

# intro

Much has been written recently on housing affordability, with much of it being negative.^[Here's a few: [CBS](https://www.cbsnews.com/news/affordable-housing-home-prices-bankrate/), [NBC](https://www.nbcnews.com/business/real-estate/exactly-unaffordable-todays-housing-market-s-getting-worse-rcna207007), and [FOX](https://www.foxbusiness.com/lifestyle/only-28-us-homes-now-affordable-typical-american-household-buying-power-drops)] Aside from the [tendency of news organizations to produce negative content](https://hai.stanford.edu/news/the-data-behind-your-doom-scroll-how-negative-news-takes-over-your-feed), I think what is lost in these reports is historical context: where were we, and where are we now? Even when the historical context is present, metrics may be used that, if not interpreted carefully, can be misleading. 

For instance, [longtermtrends.com](https://www.longtermtrends.com/home-price-median-annual-income-ratio/) gives a chart that shows the ratio of the [S&P/Case-Shiller Home Price Index](https://www.spglobal.com/spdji/en/indices/indicators/sp-cotality-case-shiller-us-national-home-price-nsa-index/#overview) to the median household income. This index is used a lot since it's high-quality and has data that dates back to 1890. However, the problem here is that the Case-Shiller index is a weighted average. The distribution of home values tend to be right skewed, so an average will be greater than the median (the *typical* house). So, dividing the average by the median produces a price-to-income ratio that is a bit more pessimistic. *The typical person is buying the typical house, not the average house.*

In order to provide some clarity on the question of housing affordability, I'm going to look at two metrics:

1. The ratio of the typical cost of a house to the typical household income. In this article, I'll refer to it as the *price-to-income ratio*.
2. The proportion of a person's monthly income that would be dedicated to their monthly mortgage. For my analysis, this will be limited to only interest and principal^[I'm interested in having a better picture of this by incorporating property taxes and home insurance costs if someone could get me the data...], and will assume a 20% downpayment, so a loan on 80% the value of a house. I'll refer to it as the *debt-to-income ratio* in the article.

# analysis

I'm *planning* to examine this at three different geographic scales:

- national
- state
- county

## national scale

### the data

The data I'm using is mostly from the [FRED](https://fred.stlouisfed.org/). I've supplemented some of these series with data extending further back to get a more complete picture. Below are the data series and where I got the supplemental data:

- [CPIAUCSL](https://fred.stlouisfed.org/series/CPIAUCSL): Consumer Price Index for All Urban Consumers: All Items in U.S. City Average
- [MEHOINUSA646N](https://fred.stlouisfed.org/series/MEHOINUSA646N): Median Household Income in the United States
  - Years 1947-1965 are from [p.877 of a US Census Bureau publication](https://www2.census.gov/library/publications/1999/compendia/statab/119ed/tables/sec31.pdf).
  - Years 1967-1983 are also from the [US Census Bureau](https://www2.census.gov/programs-surveys/demo/tables/p60/276/tableD1.xlsx)
- [MORTGAGE30US](https://fred.stlouisfed.org/series/MORTGAGE30US): 30-Year Fixed Rate Mortgage Average^[Unfortunately, there is no high-frequency median equivalent to this data that I know of. Fortunately, there are some restrictive filters (e.g. 20% down, excellent credit, excluding jumbo loans) on which data to use that removes large outliers making the mean more centered. See [here](https://www.freddiemac.com/pmms#faqs) for more details] in the United States
- [MSPUS](https://fred.stlouisfed.org/series/MSPUS): Median Sales Price of Houses Sold for the United States
  - Years 1953-1962 are from few different indices^[The [NAR Median Sales Price of Existing Homes](http://www.realtor.org/topics/existing-home-sales), [Shiller's NSA Home Sale Index](http://www.econ.yale.edu/~shiller/data.htm), and the [FHFA's NSA Existing Home Sale Index](https://www.fhfa.gov/DataTools/Downloads/Pages/House-Price-Index.aspx)] that have been combined. The author explains the process [here](https://dqydj.com/historical-home-prices/).

Let's take a look at the data below:

```{r}
#| label: fig-national-indicators
#| fig-cap: "National housing and economic indicators over time. Dollars are in nominal terms. Hover over the lines to see specific values."
#| column: body
#| out-width: "100%"

tb_viz = tb_n %>%
  drop_na() %>%
  mutate(
    clean_name = case_match(
      symbol,
      "MSPUS"         ~ "median home price",
      "MEHOINUSA646N" ~ "median household income",
      "MORTGAGE30US"  ~ "30-year fixed mortgage rate",
      "CPIAUCSL"      ~ "consumer price index",
      .default = symbol
    )
  )

# 2. Define a function to generate individual plots
createInteractivePlot = function(data, symbol_code, plot_color, y_label_fn) {
  
  # Filter for the specific series
  plot_data = data %>% 
    filter(symbol == symbol_code)
  
  # Get the clean title
  plot_title = unique(plot_data$clean_name)
  
  p = plot_data %>%
    ggplot(aes(x = date, y = price)) +
    geom_point_interactive(
      aes(
        tooltip = paste0(
          "<b>", plot_title, "</b><br>",
          "date: ", format(date, "%b %Y"), "<br>",
          "value: ", y_label_fn(price)
        ),
        data_id = date
      ),
      size = 3,         # Large target
      alpha = 0.01,     # Invisible until hovered
      color = "black"   # Base color
    ) + 
    geom_line(
      color = plot_color, 
      linewidth = 0.8
    ) +
    scale_y_continuous(labels = y_label_fn) +
    scale_x_date(limits = range(data$date)) + 
    labs(
      title = plot_title,
      x = NULL, 
      y = NULL
    )
    
  return(p)
}

# ------------------------------------------------------------------------------
# 3. Build Plots
# ------------------------------------------------------------------------------
p_home = createInteractivePlot(
  tb_viz, "MSPUS", "gray80",  
  scales::label_dollar(scale = 1e-3, suffix = "k") 
)

p_income = createInteractivePlot(
  tb_viz, "MEHOINUSA646N", "gray80", 
  scales::label_dollar(scale = 1e-3, suffix = "k")
)

p_rate = createInteractivePlot(
  tb_viz, "MORTGAGE30US", "gray80", 
  scales::label_number(accuracy = 0.01, scale = 1, suffix = "%")
)

p_cpi = createInteractivePlot(
  tb_viz, "CPIAUCSL", "gray80", 
  scales::label_number(accuracy = 0.01)
)

# ------------------------------------------------------------------------------
# 4. Combine and Render
# ------------------------------------------------------------------------------
combined_plot = (p_home + p_income) / (p_rate + p_cpi) +
  plot_annotation(
    title = "national housing & economic indicators",
    theme = theme(
      plot.background = element_rect(fill = "#070607", color = "#070607"),
      plot.title = element_text(color = "gray80", size = 16, face = "bold"),
      plot.subtitle = element_text(color = "gray50", size = 12)
    )
  )

# Create the widget
girafe(
  ggobj = combined_plot,
  width_svg = 9,
  height_svg = 6,
  bg = "#070607", 
  options = list(
    opts_hover(css = "fill: white; opacity: 1; stroke: white; stroke-width: 2px;"),
    opts_tooltip(
      css = "background-color: #070607; color: gray80; padding:8px; border:1px solid gray50;"
    ),
    # Removed invalid 'css' argument here
    opts_toolbar(saveaspng = F) 
  )
)
```

There are a few things that need to be handled before analysis:

1. The data is captured at different frequencies. 
2. Not all the data is recent.^[The 30-year fixed mortgage rate is the most egregious offender. The reason for this, is that Freddie Mac began surveying lenders on mortgage rates in April 1971, making this the earliest date for which consistent, nationwide data is available.]

```{r}
#| label: tbl-observation-dates
#| tbl-cap: "Latest data points retrieved for each national economic series."

tb_viz %>% 
  group_by(clean_name) %>% 
  summarize(
    `oldest observation` = format(min(date), "%B %e, %Y"),
    `newest observation` = format(max(date), "%B %e, %Y")
  ) %>% 
  right_join(
    tibble(
      clean_name = c("consumer price index", "median household income", "30-year fixed mortgage rate", "median home price"),
      `collection frequency` = c("monthly", "annually", "weekly", "quarterly")
    ),
    by = "clean_name"
  ) %>% 
  rename(series = clean_name) %>% 
  relocate(series, `collection frequency`) %>% 
  kable(
    format = "html"
  )
```

To account for (1), I put everything in a monthly frequency. Cubic splines were used for quarterly and annual data, while weekly data was averaged. For (2), I first smoothed each series using [LOESS](https://en.wikipedia.org/wiki/Local_regression) then modeled each series using [ARIMA](https://en.wikipedia.org/wiki/Autoregressive_integrated_moving_average) to produce estimates for the most recent date available (`r format(max(tb_final01$date), '%B %Y')`). These estimates should be taken with a grain of salt, though I include $3 \sigma$ prediction intervals to capture the uncertainty. 

```{r}
#| label: fig-national-indicators-harmonized
#| fig-cap: "Harmonized and smoothed economic indicators over time. Green line shows the smoothed series. Gray line shows the raw series. Dollars are in nominal terms. Hover over the lines to see specific values."
#| column: body
#| out-width: "100%"
#| warning: false

tb_viz_nm = tb_nm %>%
  mutate(
    clean_name = case_match(
      symbol,
      "MSPUS"         ~ "median home price",
      "MEHOINUSA646N" ~ "median household income",
      "MORTGAGE30US"  ~ "30-year fixed mortgage rate",
      "CPIAUCSL"      ~ "consumer price index",
      .default = symbol
    )
  )

# 2. Define function for Synced Plots with Ribbons
createSyncedPlot = function(data, symbol_code, plot_color, y_label_fn) {
  
  plot_data = data %>% 
    filter(symbol == symbol_code)
  
  plot_data2 = tb_viz %>% 
    filter(symbol == symbol_code)
  
  plot_title = unique(plot_data$clean_name)
  
  p = plot_data %>%
    mutate(
      tooltip_ = ifelse(
        pred_sd == 0,
        paste0(
          "<b>", plot_title, "</b><br>",
          "date: ", format(date, "%b %Y"), "<br>",
          "value: ", y_label_fn(price)
        ),
         paste0(
          "<b>", plot_title, "</b><br>",
          "date: ", format(date, "%b %Y"), "<br>",
          "value: ", y_label_fn(price), "<br>",
          "range: ", y_label_fn(price - 3 * pred_sd), " - ", y_label_fn(price + 3 * pred_sd)
    )
      )
    ) %>% 
    ggplot(aes(x = date, y = price)) +
    geom_line(
      data = plot_data2,
      color = "gray80", 
      linewidth = 0.8,
      alpha = 0.7
    ) + 
    # Layer 1: Prediction Interval Ribbon
    # This is static (not interactive), just visual context
    geom_ribbon(
      aes(ymin = price - 3 * pred_sd, ymax = price + 3 * pred_sd),
      alpha = 0.4,
      fill = "gray40", # Darker gray to match dark theme better
      color = NA
    ) +
    # Layer 2: The Interactive Point (Invisible until hovered)
    # CRITICAL: data_id = date allows the plots to talk to each other
    geom_point_interactive(
      aes(
        tooltip = tooltip_,
        data_id = date 
      ),
      size = 3,          
      alpha = 0.01,      # Invisible default state
      color = "black",
      hover_nearest = TRUE
    ) + 
    # Layer 3: The visual line
    geom_line(
      color = plot_color, 
      alpha = 0.7,
      linewidth = 0.8
    ) +
    scale_y_continuous(labels = y_label_fn) +
    scale_x_date(limits = range(data$date)) + 
    labs(
      title = plot_title,
      x = NULL, 
      y = NULL
    )
    
  return(p)
}

# ------------------------------------------------------------------------------
# 3. Build Plots
# ------------------------------------------------------------------------------

fit_color = "#ffa500"

p_home = createSyncedPlot(
  tb_viz_nm, "MSPUS", fit_color,  
  scales::label_dollar(scale = 1e-3, suffix = "k") 
)

p_income = createSyncedPlot(
  tb_viz_nm, "MEHOINUSA646N", fit_color, 
  scales::label_dollar(scale = 1e-3, suffix = "k")
)

p_rate = createSyncedPlot(
  tb_viz_nm, "MORTGAGE30US", fit_color, 
  scales::label_number(accuracy = 0.01, scale = 1, suffix = "%")
)

p_cpi = createSyncedPlot(
  tb_viz_nm, "CPIAUCSL", fit_color, 
  scales::label_number(accuracy = 0.01)
)

# ------------------------------------------------------------------------------
# 4. Combine and Render
# ------------------------------------------------------------------------------

combined_plot = (p_home + p_income) / (p_rate + p_cpi) +
  plot_annotation(
    title = "smoothed economic indicators",
    theme = theme(
      plot.background = element_rect(fill = "#070607", color = "#070607"),
      plot.title = element_text(color = "gray80", size = 16, face = "bold"),
      plot.subtitle = element_text(color = "gray50", size = 12)
    )
  )

# Create the widget
girafe(
  ggobj = combined_plot,
  width_svg = 9,
  height_svg = 6,
  bg = "#070607", 
  options = list(
    # CSS for the 'active' state (when hovered or synced)
    # The opacity: 1 here makes the invisible points visible on all plots
    opts_hover(css = "fill: #006203; opacity: 1; stroke: white; stroke-width: 2px;"),
    
    # CSS for the tooltip box
    opts_tooltip(
      css = "background-color: #070607; color: gray80; padding:8px; border:1px solid gray50;"
    ),
    
    # Inverted logic: 'hover_inv' defines style for non-selected points (dim them slightly?)
    # Usually irrelevant if points are invisible, but good hygiene
    opts_hover_inv(css = "opacity: 0.01;"),
    
    opts_toolbar(saveaspng = F) 
  )
)
```

These smoothed indicators are used to calculate the metrics in the following sections.

### adjusted median home price

Let's put the nominal median home price in `r cpi_baseline_year` dollars. I'll include a linear model to help us understand the trend over time.

```{r}
#| label: fig-adjusted-home-price
#| fig-cap: !expr paste0("Adjusted median home prices (", cpi_baseline_year, " dollars) over time. Monthly forecasts with 3$\\sigma$ prediction interval. Linear model with 3$\\sigma$ confidence interval.")
#| column: body
#| out-width: "100%"

# helper function for generating these interactive plots with trend lines:
createForecastPlot = function(
    data_main, 
    data_lm, 
    y_col, 
    y_l_col, 
    y_u_col, 
    y_sd_col, 
    title_text, 
    y_label_fn = scales::label_number(accuracy = 0.01)
) {
  
  # Helper for date formatting inside the function
  fmt_date = function(d) format(d, "%b %Y")
  
  # 1. Prepare data with dynamic tooltips
  # We use .data[[col_name]] to access columns by string variable
  plot_data = data_main %>% 
    mutate(
      tooltip_text = ifelse(
        .data[[y_sd_col]] == 0,
        paste0(
          "<b>", title_text, "</b><br>",
          "date: ", fmt_date(date), "<br>",
          "value: ", y_label_fn(.data[[y_col]]), "<br>"
        ),
        paste0(
          "<b>", title_text, "</b><br>",
          "date: ", fmt_date(date), "<br>",
          "value: ", y_label_fn(.data[[y_col]]), "<br>",
          "range: ", y_label_fn(.data[[y_l_col]]), " - ", y_label_fn(.data[[y_u_col]])
        )
      )
    )
    
  # 2. Build the ggplot object
  gg_interactive = plot_data %>% 
    ggplot(aes(x = date, y = .data[[y_col]])) + 
    
    # --- Main Series ---
    geom_ribbon(
      aes(ymin = .data[[y_l_col]], ymax = .data[[y_u_col]]), 
      alpha = 0.4, color = NA, fill = "gray50"
    ) + 
    geom_point_interactive(
      aes(
        tooltip = tooltip_text,
        data_id = as.character(date)
      ),
      size = 3,        
      alpha = 0.001,   # Invisible, for hover detection
      color = "black" 
    ) +
    
    # --- Linear Model Series ---
    # Points for interaction
    geom_point_interactive(
      data = data_lm,
      aes(
        y = fit,
        tooltip = paste0(
          "<b>linear model fit</b><br>",
          "date: ", fmt_date(date), "<br>",
          "fit value: ", y_label_fn(fit), "<br>",
          "fit range: ", y_label_fn(fit_lower), " - ", y_label_fn(fit_upper)
        ),
        data_id = paste0("lm-", as.character(date)) 
      ),
      size = 3, 
      alpha = 0.001, 
      color = "black"
    ) +
    # Visual Line (Main)
    geom_line(color = "gray80", linewidth = 0.8) + 
    
    # Linear Model Visuals (Ribbon + Line)
    geom_ribbon(
      data = data_lm, 
      aes(ymin = fit_lower, ymax = fit_upper), 
      alpha = 0.4, color = NA, fill = "#ffa500"
    ) + 
    geom_line(
      data = data_lm, 
      aes(y = fit), 
      color = "#ffa500", linewidth = 0.8
    ) +
    
    # --- Formatting ---
    scale_y_continuous(labels = y_label_fn) + # <--- Added this line
    labs(
      x = NULL,
      y = NULL,
      title = title_text
    ) + 
    theme(
      plot.background = element_rect(fill = "#070607", color = "#070607"),
      plot.title = element_text(color = "gray80", size = 16, face = "bold"),
      plot.subtitle = element_text(color = "gray50", size = 12),
      axis.text = element_text(color = "gray80"),
      panel.background = element_rect(fill = "#070607", color = "#070607"),
      panel.grid.major = element_line(color = "gray30", linewidth = 0.2),
      panel.grid.minor = element_blank()
    )

  # 3. Render Girafe
  girafe(
    ggobj = gg_interactive,
    width_svg = 9, 
    height_svg = 3,
    bg = "#070607",
    options = list(
      opts_hover(css = "fill: white; opacity: 1; stroke: none;"),
      opts_tooltip(
        css = "background-color: #070607; color: gray80; padding: 10px; border: 1px solid gray50; border-radius: 2px;"
      ),
      opts_toolbar(saveaspng = FALSE)
    )
  )
}

createForecastPlot(
  data_main = tb_final01 %>% filter(!is.na(home_real)),
  data_lm = hp_data$tb,
  y_col = "home_real",
  y_l_col = "home_real_l",
  y_u_col = "home_real_u",
  y_sd_col = "home_real_sd",
  title_text = "adjusted median home price",
  y_label_fn = scales::label_dollar(scale = 1e-3, suffix = "k")
)
```

### adjusted household income

Let's put the nominal median household income in `r cpi_baseline_year` dollars. I'll include a linear model to help us understand the trend over time.

```{r}
#| label: fig-adjusted-household-income
#| fig-cap: !expr paste0("Adjusted median household income (", cpi_baseline_year, " dollars) over time. Monthly forecasts with 3$\\sigma$ prediction interval. Linear model with 3$\\sigma$ confidence interval.")
#| column: body
#| out-width: "100%"

createForecastPlot(
  data_main = tb_final01,
  data_lm = hi_data$tb,
  y_col = "income_real",
  y_l_col = "income_real_l",
  y_u_col = "income_real_u",
  y_sd_col = "income_real_sd",
  title_text = "adjusted median household income",
  y_label_fn = scales::label_dollar(scale = 1e-3, suffix = "k")
)
```


### price-to-income ratio

We can use nominal dollars to calculate the price to income ratio. I'll include a linear model to help us understand the trend over time.

```{r}
#| label: fig-price-to-income-ratio
#| fig-cap: "Price-to-income ratio over time. Monthly forecasts with 3$\\sigma$ prediction interval. Linear model with 3$\\sigma$ confidence interval."
#| column: body
#| out-width: "100%"

createForecastPlot(
  data_main = tb_final01 %>% filter(!is.na(pi_ratio)),
  data_lm = pi_data$tb,
  y_col = "pi_ratio",
  y_l_col = "pi_l",
  y_u_col = "pi_u",
  y_sd_col = "pi_sd",
  title_text = "price-to-income ratio",
  y_label_fn = scales::label_number(accuracy = 0.01)
)
```

### debt-to-income ratio

```{r}
#| label: fig-debt-to-income-ratio
#| fig-cap: "Debt-to-income ratio over time. Monthly forecasts with 3$\\sigma$ prediction interval. Linear model with 3$\\sigma$ confidence interval."
#| column: body
#| out-width: "100%"

createForecastPlot(
  data_main = tb_final01 %>% filter(!is.na(dti_ratio)),
  data_lm = di_data$tb,
  y_col = "dti_ratio",
  y_l_col = "dti_l",
  y_u_col = "dti_u",
  y_sd_col = "dti_sd",
  title_text = "debt-to-income ratio",
  y_label_fn = scales::label_percent(accuracy = 1)
)
```

